// O(n), O(n) - this fails on big input
class Solution {
    public long subArrayRanges(int[] nums) {
        return (maxSubArray(nums) - minSubArray(nums));
    }

    public int maxSubArray(int[] nums){
        int n = nums.length;
        int[] prevGreater = new int[n]; int[] nextGreater = new int[n];
        int mod = (int)(1e9 + 7);
        Stack<Integer> st = new Stack<>();
        //prev Greater element
        for(int i = 0; i < n; i++){
            while(!st.isEmpty() && nums[st.peek()] <= nums[i]){
                st.pop();
            }

            prevGreater[i] = st.isEmpty() ? i + 1 : i - st.peek();
            st.push(i);
        }

        st.clear();

        //next less element
        for(int i = n-1; i >= 0; i--){
            while(!st.isEmpty() && nums[st.peek()] < nums[i]){
                st.pop();
            }

            nextGreater[i] = st.isEmpty() ? n - i : st.peek() - i;
            st.push(i);
        }

        long res = 0;
        for(int i = 0; i < n; i++){
            long count = prevGreater[i] * nextGreater[i];
            res = (res + count * nums[i]) % mod;
        }

        return (int)res;
    }

    public int minSubArray(int[] nums){
        int n = nums.length;
        int[] prevLess = new int[n]; int[] nextLess = new int[n];
        int mod = (int)(1e9 + 7);
        Stack<Integer> st = new Stack<>();
        //prev less element
        for(int i = 0; i < n; i++){
            while(!st.isEmpty() && nums[st.peek()] > nums[i]){
                st.pop();
            }

            prevLess[i] = st.isEmpty() ? i + 1 : i - st.peek();
            st.push(i);
        }

        st.clear();

        //next less element
        for(int i = n-1; i >= 0; i--){
            while(!st.isEmpty() && nums[st.peek()] >= nums[i]){
                st.pop();
            }

            nextLess[i] = st.isEmpty() ? n - i : st.peek() - i;
            st.push(i);
        }

        long res = 0;
        for(int i = 0; i < n; i++){
            long count = prevLess[i] * nextLess[i];
            res = (res + count * nums[i]) % mod;
        }

        return (int)res;
    }
}

// This handles edge cases which is failing for above
class Solution {
    public long subArrayRanges(int[] nums) {
        return (totalMax(nums) - totalMin(nums));
    }

    private long totalMax(int[] nums) {
        int n = nums.length;
        Stack<Integer> stack = new Stack<>();
        long total = 0;

        for (int i = 0; i <= n; i++) {
            while (!stack.isEmpty() && (i == n || nums[stack.peek()] < (i < n ? nums[i] : Integer.MAX_VALUE))) {
                int mid = stack.pop();
                int left = stack.isEmpty() ? -1 : stack.peek();
                int right = i;
                long count = (long)(mid - left) * (right - mid);
                total += count * nums[mid];
            }
            stack.push(i);
        }
        return total;
    }

    private long totalMin(int[] nums) {
        int n = nums.length;
        Stack<Integer> stack = new Stack<>();
        long total = 0;

        for (int i = 0; i <= n; i++) {
            while (!stack.isEmpty() && (i == n || nums[stack.peek()] > (i < n ? nums[i] : Integer.MIN_VALUE))) {
                int mid = stack.pop();
                int left = stack.isEmpty() ? -1 : stack.peek();
                int right = i;
                long count = (long)(mid - left) * (right - mid);
                total += count * nums[mid];
            }
            stack.push(i);
        }
        return total;
    }
}
